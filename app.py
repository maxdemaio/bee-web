from flask import Flask, render_template, request, jsonify
from typing import List
from dataclasses import dataclass

app = Flask(__name__)

@dataclass
class WordBinaryMap:
    word: str
    binary: int

def read_word_binary_map(file_path) -> List[WordBinaryMap]:
    word_binary_map_list = []
    
    with open(file_path, 'rb') as f:
        # Read the file in chunks of 36 bytes (32 bytes for word + 4 bytes for binary)
        while True:
            chunk = f.read(36)
            if len(chunk) < 36:
                break  # End of file reached or incomplete chunk

            # Extract the 32-byte word and the 4-byte binary
            word_bytes = chunk[:32]
            binary_bytes = chunk[32:]
            
            # Convert the word bytes to a string (remove any null padding bytes)
            word = word_bytes.decode('utf-8').rstrip('\x00')
            
            # Convert the 4-byte binary into a 32-bit unsigned integer
            binary = int.from_bytes(binary_bytes, byteorder='little')
            
            # Append the word and its binary to the list
            word_binary_map_list.append((word, binary))
    
    return word_binary_map_list


def negate_binary(binary):
    return ~binary & 0xFFFFFFFF  # Flip bits and mask to 32-bit


def string_to_binary(word):
    binary = 0
    for char in word.lower():  # Convert to lowercase to handle case insensitivity
        if 'a' <= char <= 'z':  # Ensure it's a valid alphabet letter
            position = ord(char) - ord('a')  # Calculate the position of the letter (0-25)
            binary |= (1 << position)  # Flip the bit at the calculated position
    # Bitwise not operation to create the solution cypher
    return binary


@app.route("/")
def index():
    return render_template("index.html")

@app.route("/solve", methods=["POST"])
def solve_puzzle():
    letters = request.form["letters"].lower()
    required_letter = request.form["required_letter"].lower()
    print("Letters:", letters)
    print("Required letter:", required_letter)

    # Validate the input
    if not letters.isalpha() or len(letters) > 6 or not required_letter.isalpha() or len(required_letter) != 1:
        return jsonify({"error": "Invalid input"}), 400

    #### Generate Solution Cypher
    binary_representation = string_to_binary(letters + required_letter)
    cypher = negate_binary(binary_representation)

    # Format as a 32-bit binary string for debugging purposes
    binary_string = f"{cypher:032b}"
    print(f"Letters and required letter: {letters + required_letter}")
    print(f"Binary (32-bit): {binary_string}")

    #### Go over word binary struct generated by C program
    #### Compare the solution cypher with the binary representation of each word
    valid_words = []
    pangrams = []

    # Calculate the position of the required letter in the alphabet (0 for 'a', 1 for 'b', ...)
    required_bit_position = ord(required_letter) - ord('a')

    word_binary_map_file = 'word_bin_map.bin'  # Path to binary file
    word_binary_map = read_word_binary_map(word_binary_map_file)

    # Print the words and their binary representations
    for word, binary in word_binary_map:
        print(f"Word: {word}, Binary: {bin(binary)}")
        
        # Perform bitwise AND operation, check if the required bit is set and the word is longer than 3 characters
        result = cypher & binary
        if result == 0 and binary & (1 << required_bit_position) and len(word) > 3:
            valid_words.append(word)
        if binary == binary_representation:
            pangrams.append(word)
        # Print the result in binary format
        print(f"Bitwise AND result: {bin(result)}")

    return jsonify({"words": valid_words, "pangrams": pangrams})

if __name__ == "__main__":
    app.run(port=8000, debug=True)





